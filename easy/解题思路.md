# 解题思路--简单题

更新日期：2019-09-03

## 007 [整数反转](https://leetcode-cn.com/problems/reverse-integer/)

### 字符串处理思路

当成字符串的反转问题来处理，使用的是字符串的灵活索引机制

### 数学运算思路

对10取余，便得到了最后一位数字，除以10，便除去了最后一位数字；
同时不断的乘10，便可以把后面的数字不断的往前推，通过进制的处理方式，很自然，同时末尾0的问题也很自然的解决掉了。

### 007 需要注意的地方

* 符号位判断：也许第二种思路可以合并这个问题，但是发现一个有趣的东西 `1 // 10 = 0` 而 `-1 // 10 = -1`
* 末尾0的问题
* 位数有限的溢出问题

### 007 补充

针对符号位的问题，发现C语言和python的整除除法和取余机制是不同的，所以用C的话是不用考虑符号位的问题的。

## 009 [回文数](https://leetcode-cn.com/problems/palindrome-number/)

这道题目上面的007挺像的，可以算是上一题的延申吧，做个反转相减就行了，但是也有其它的方式。比如想到了双指针那种方式，一个从头，一个从末尾，一个个比较，直到两个相遇表示相同。

### 009 字符串处理思路

一个是反转，一个是头尾同时比较的，利用索引都可以很简单的完成。

### 009 数学运算思路

末尾数字好获取，关键是头部的数字如何一个个给弹出来呢？

### 009 需要注意的地方

* 符号位判断：负数按条件直接不是 `1 // 10 = 0` 而 `-1 // 10 = -1`
* log(0)的问题
* 首位的弹出需要仔细考虑啊

### 009 补充

晚上看了题解，发现只要类似007的方法反转一半就可以了判断了，这个思路的关键是判断什么时候反转了一半，这一点通过比较大小实现了。
起码比我这个疯狂弹出头部数字的可简单多了，不过也算是多了一个方法吧。

按照题解思路一直有个特殊判断搞不定，这样只反转一半，而且不要那么麻烦搞头部操作，果然快了不少。

## 013 [罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)

### 思路很简单

1、首先是7个字符和数值的对应，可以用字典
2、正常规则，左大右小每个字符对应数值直接相加
3、特例规则，条件，左小右大，合为一个数字，大减小

实际写也挺简单的说，这几天写下来感觉while用的多，然后边界条件要处理好。

## 014 [最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

先总结，本来觉得我脑洞够大了，结果发现天天两行python的那个老哥，贼鸡儿牛逼，充分发挥了语言自身的特点，我佛了。

### 思路记录--strcmp

1、注意"前缀"，意味着必然从头开始
2、利用python具有str cmp的机制进行sorted
3、找到最短的一个，和sorted后的头尾对比得到结果

满足这几个条件，只需要比三个字符串就ok了，虽然我是这么搞出来的，但有时候自己这个逻辑都想不通。牺牲点一个是排序，再一个遍历序列得到最短长度。

### 014 补充

leetcode的测试用例真的是，只有你想不到。还有再测试代码的时候，测试用例输入格式错误的话会报错啊，查了好一会代码的错。
